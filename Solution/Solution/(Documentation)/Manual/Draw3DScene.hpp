
/**
* \page Draw3DSceneBriefPage
*
*  Описание отрисовки 3D объектов в окне с использованием
*  [компонентной системы](\ref CovelliteApiComponentSystemPage).
*/

/**
* \page Draw3DScenePage Отрисовка 3D объектов
*
* \copydoc Draw3DSceneBriefPage
*
*  Используемые термины
*  ====================
*
* \copydoc CovelliteApiGlossaryPage
*
* \note
*  - В данном описании под \b объектом подразумевается 'объект 3D сцены',
*  а под \b сценой - '3D сцена'.
*  - Обозначение компонента как State.Scissor подразумевает объект
*  компонента, у которого установлены параметры type == 'State' и
*  kind == 'Scissor'.
*  - Под \b объектом \b компонента подразумевается объект C++ класса компонента.
*
*  Подробнее о компонентах и их параметрах см.
*  \ref CovelliteApiComponentSystemPage.
*
*  Общее описание
*  ==============
*
*  Используемый формат вершин:
*
* \snippet .\Solution\Example\Example\Basements\Simple3DObject.cpp Vertex format
*
*  Отрисовка производится при помощи формирования \b сцены, содержащей рендеры:
*  - \b Камеры - уникальный объект, определяющий способ отрисовки сцены.
*  - \b Общих \b объектов (настройки конвеера рендеринга и источники света).
*  - \b Объектов, которые непосредственно формируют требуемое изображение
*  на экране.
*
*  Сцен может быть несколько, при рендеринге нескольких сцен текущая сцена
*  будет отрисоваваться поверх предыдущей; также можно сформировать несколько
*  различных сцен, каждую из которых отрисовывать в зависимости от неких
*  условий.
*
*  Создание и удаление рендеров для компонентов производится через объект,
*  получаемый при помощи функции covellite::api::IWindow::GetRenders().
*  
* \warning
*  Реализация OpenGL требует, чтобы рендеры создавались и активировались
*  в том же потоке, в котором было создано окно графического Api.
*
* \note
*  При создании рендеров для разных \b объектов \b компонентов с одним и тем же
*  \b id будет возвращен один и тот же объект рендера (это позволяет, например,
*  один раз сформировать набор общих для всех объектов рендеров, а затем
*  обращаться к ним через \b объекты \b компонентов, содержащих только
*  идентификаторы), но при этом следует учитывать, что для некоторых типов
*  компонентов рендеры не создаются (например, компоненты Data вместо этого
*  захватываются и используются рендерами других компонентов). Для таких
*  компонентов параметр \b id не имеет смысла и при необходимости использования
*  несколькими объектами одного и того же компонента (например, для совместного
*  перемещения группы объектов), следует использовать один и тот же \b объект
*  \b компонента.
*
*  Разные объекты могут использовать рендеры, выполняющие одно и то же
*  действие, в этом случае для экономии ресурсов можно создать эти рендеры
*  (один раз) заранее, а дальнейшем использовать их через компоненты
*  с соответствующими id.
*  
*  Камера и настройки конвеера рендеринга
*  --------------------------------------
*
* \note
*  Здесь и далее все создаваемые наборы рендеров добавляются в общий набор
*  объектов, а \b сцена представляет собой список идентификаторов объектов
*  в этом наборе.
*
*  В данном примере формируется объект, состоящий из рендеров:
*  - Компонент точки в пространстве, в которую 'смотрит' камера.
*  - Перспективной камеры.
*  - Рендера, очищающего задний буфер и заливающего его указанным цаетом.
*  - Рендера, включающего использование буфера глубины и очищающего его.
*  - Рендера настроек использования текстуры.
*
* \snippet .\Solution\Example\Example\Basements\Simple3DObject.cpp Create camera
*  
*  Источники света
*  ---------------
*  
*  Фоновый и направленный источники света:
*  
* \snippet .\Solution\Example\Example\Basements\Simple3DObject.cpp Create lights
*  
*  Рендеринг объектов
*  ------------------
*
*  Объект, отображаемый на экране, представляет собой набор рендеров, который
*  создается на основе набора компонентов и должен включать:
*  - Вершинный шейдер.
*  - Пиксельный шейдер.
*  - Текстуру.
*  - Вертексный буфер.
*  - Индексный буфер.
*  - Компоненты положения/ориентации/масштабирования (не обязательны).
*  - Present.Geometry (именно он осуществляет отрисовку объекта, поэтому
*  должен располагаться последним).
*
*  Поскольку для различных реализаций (OpenGL или DirectX) требуются шейдеры
*  в разных форматах, для обеспечения кроссплатформенности кода необходимо
*  предоставить шейдеры для всех поддерживаемых реализаций (например, для
*  DirectX используется компонент Data.Shader.HLSL); не подходящие для
*  текущего графического Api будут проигнорированы при создании рендеров.
*
*  Компоненты Data.Position/Data.Rotation/Data.Scale используются для
*  перемещения/вращения/изменения размеров объектов без их пересоздания
*  (достаточно установить новые значения параметров при обновлении сцены),
*  причем:
*  - Компонентов одного типа может быть несколько (что позволяет, например,
*  создавать группы объектов, которые должны быть расположены относительно
*  друг друга определенным образом, но при этом двигаться/вращаться вместе;
*  во втором случае необходимо использовать общий \b объект \b компонента,
*  использование разных объектов с одинаковым \b id нужного эффекта не даст).
*  - Важен порядок следования компонентов (поворот-перемещение даст сначала
*  поворот вокруг точки [0, 0, 0] с нулевым радиусом, а затем уже смещение
*  повернутого объекта, а перемещение-поворот даст сначала смещение от точки
*  [0, 0, 0], а затем уже поворот вокруг нее с радиусом смещения).
*
* \todo
*  - Добавить картинку, объясняющую разницу между поворот-смещение и
*  смещение-поворот.
*
* ### Текстурированный объект
*
*  Текстуры, которые будут использоваться, можно подгрузить заранее, чтобы
*  потом ссылаться на них по их идентификатору.
*
* \snippet .\Solution\Example\Example\Basements\Common.cpp Load texture
*
*  Пример формирования текстурированного объекта; по порядку:
*  - Вертексный шейдер для отрисовки текстурированных объектов, использующий
*  шейдер по умолчанию.
*  - Пиксельный шейдер для отрисовки объектов c текстурой, использующий
*  шейдер по умолчанию.
*  - Материал поверхности.
*  - Текстура (создана ранее).
*  - Вертексный буфер, содержащий уникальные для данного объекта данные вершин.
*  - Индексный буфер, содержащий уникальные для данного объекта данные вершин.
*  - Компонент масштабирования.
*  - Компонент вращения (создан заранее, что можно было обновлять его
*  значения перед отрисовкой каждого кадра).
*  - Компонент смещения.
*  - Компонент отрисовки объекта.
*
* \snippet .\Solution\Example\Example\Basements\Simple3DObject.cpp Textured object
*
* \note
*  - Можно использовать текстуру, содержащую несколько изображений для
*  разных объектов, но при этом все равно необходимо устанавливать компонент
*  этой текстуры \b каждому объекту, т.к. Present.Geometry отключает
*  использование текстур после отрисовки объекта.
*  
* ### Скайбокс
*  
*  Для отрисовки скайбокса необходимо сформировать отдельную сцену, содержащую
*  компоненты:
*  - Камеры, которая 'смотрит' в начало координат с нулевой дистанции и
*  вращается синхронно с камерой, привязанной к персонажу, управляемому игроком.
*  - Компонента, отключающего использование буфер глубины.
*  - Фоновый источник света и материал белого цвета (0xFFFFFFFF).
*  - Шейдеры, текстуру и куб в начале координат, вертексный буфер которого
*  сформирован таким образом, чтобы отрисовывались его внутренние поверхности.
*  
*  Подготовка 3D модели
*  ====================
*  
* \warning
*  Visual Studio умеет отображать и редактировать 3D модели (форматы .obj, .dae
*  и .fbx), но при сохранении результата в файл .obj он сохраняется как utf8
*  \b без \b сигнатуры, после чего при повторном открытии этого файла он
*  открывается как текстовый файл. Чтобы Visual Studio открыл его в 3D
*  редакторе, необходимо пересохранить файл как utf8 \b с \b сигнатурой.
*  
*  При подготовке файла 3D модели к использованию фреймворком возможны
*  следующие действия:
*  
* ### Триангуляция
*  
*  3D редактор Visual Studio:
*  
* \image html ".\Solution\(Documentation)\Manual\Triangulation.png"
*
* ### Перенос/поворот/масштабирование модели
*  
*  3D редактор Visual Studio:
*  
* \image html ".\Solution\(Documentation)\Manual\Transformation.png"
*  
* ### Объединение нескольких текстур в одну
*  
*  Фреймворк поддерживает использование только одной текстуры для одной модели
*  (модель = вертексный + индексный буфер), поэтому для файлов, содержащих
*  несколько отдельных моделей, каждой из которых задана своя текстура,
*  необходимо произвести объединение мешей (это делает 3D редактор Visual
*  Studio) и текстур (например, при помощи GIMP). Проблема заключается в том,
*  что у 3D модели необходимо модифицировать текстурные координаты таким
*  образом, чтобы она правильно отображалась с объединенной текстурой.
*  
*  При помощи Blender'а это можно сделать так:
*  - Открываем файл 3D модели и переключаемся в режим редактирования текстурных
*  координат.
*  
* \image html ".\Solution\(Documentation)\Manual\UVImageEditor.png"
*  
*  - Для материала каждой модели - выбираем его, наводим курсор на поле
*  развертки и нажимаем A, чтобы выделить всю развертку целиком.
*  
* \image html ".\Solution\(Documentation)\Manual\SelectAll.png"
*  
*  - Для изменения масштаба нажимаем S (после чего X или Y, если
*  масштабирование требуется только по одной оси) и, перемещая мышь, изменяем
*  размер развертки до требуемого (с зажатым Ctrl - с шагом 0.1).
*  
* \image html ".\Solution\(Documentation)\Manual\ScaleX.png"
*  
*  - Для перемещения нажимаем G и, перемещая мышь, перемещаем развертку
*  в нужное место текстуры (с зажатым Ctrl - с шагом 1/8 размера текстуры).
*  
* \image html ".\Solution\(Documentation)\Manual\Translate.png"
*  
*  - После экспорта результата модель будет использовать новые текстурные
*  координаты.
*/
