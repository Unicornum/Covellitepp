
/**
* \page Draw2DSceneBriefPage
* 
*  Описание отрисовки в окне программы плоских объектов с использованием 
*  [компонентной системы](\ref CovelliteApiComponentSystemPage).
*/

/**
* \page Draw2DScenePage Отрисовка 2D объектов
*  
* \copydoc Draw2DSceneBriefPage
*  
*  Используемые термины
*  ====================
*
* \copydoc CovelliteApiGlossaryPage
*  
* \note
*  - В данном описании под \b объектом подразумевается 'объект 3D сцены', 
*  а под \b сценой - '3D сцена'.
*  - Обозначение компонента как State.Scissor подразумевает объект
*  компонента, у которого установлены параметры type == 'State' и 
*  kind == 'Scissor'.
*  - Под \b объектом \b компонента подразумевается объект C++ класса компонента.
*  
*  Подробнее о компонентах и их параметрах см. 
*  \ref CovelliteApiComponentSystemPage.
*  
*  Общее описание
*  ==============
*  
*  Хотя [компонентная система](\ref CovelliteApiComponentSystemPage) 
*  предназначена - в первую очередь - для отрисовки трехмерных сцен, 
*  тем не менее она позволяет также рисовать в окне простые плоские объекты 
*  (именно этот режим используется для отрисовки GUI). Идея состоит в том, 
*  что при помощи специальной ортогональной камеры (которая 'смотрит' 
*  на плоскость Oxy со стороны положительных значений оси z) отображаются 
*  объекты, состоящие из треугольников, вершины которых лежат в плоскости Oxy.
*  
*  Используемый формат вершин:
*
* \snippet .\Solution\Example\Example\Basements\Simple2DGame.hpp Vertex format
*  
*  Отрисовка производится при помощи формирования \b сцены, содержащей рендеры:
*  - \b Камеры - уникальный объект, определяющий способ отрисовки сцены.
*  - \b Общих \b объектов (например, настройки конвеера рендеринга).
*  - \b Объектов, которые непосредственно формируют требуемое изображение
*  на экране.
*  
*  Сцен может быть несколько, при рендеринге нескольких сцен текущая сцена
*  будет отрисоваваться поверх предыдущей; также можно сформировать несколько
*  различных сцен, каждую из которых отрисовывать в зависимости от неких 
*  условий.
*  
*  Создание и удаление рендеров для компонентов производится через объект,
*  получаемый при помощи функции covellite::api::IWindow::GetRenders().
*  
* \warning
*  Реализация OpenGL требует, чтобы рендеры создавались и активировались
*  в том же потоке, в котором было создано окно графического Api.
*  
* \note
*  При создании рендеров для разных \b объектов \b компонентов с одним и тем же 
*  \b id будет возвращен один и тот же объект рендера (это позволяет, например, 
*  один раз сформировать набор общих для всех объектов рендеров, а затем 
*  обращаться к ним через \b объекты \b компонентов, содержащих только 
*  идентификаторы), но при этом следует учитывать, что для некоторых типов 
*  компонентов рендеры не создаются (например, компоненты Data вместо этого 
*  захватываются и используются рендерами других компонентов). Для таких 
*  компонентов параметр \b id не имеет смысла и при необходимости использования 
*  несколькими объектами одного и того же компонента (например, для совместного 
*  перемещения группы объектов), следует использовать один и тот же \b объект 
*  \b компонента.
*  
*  Разные объекты могут использовать рендеры, выполняющие одно и то же 
*  действие, в этом случае для экономии ресурсов можно создать эти рендеры 
*  (один раз) заранее, а дальнейшем использовать их через компоненты 
*  с соответствующими id.
*  
*  Пример создания рендера индесного буфера, который в дальнейшем будет
*  использоваться для всех объектов:
*  
* \snippet .\Solution\Example\Example\Basements\Simple2DGame.cpp Common objects
*
* \note
*  Далее в примерах в качестве объектов будут использоваться прямоугольники,
*  состоящие из двух треугольников, но на практике объекты могут быть любой
*  формы из любого количества треугольников (ограничением являются лишь
*  возможности железа).
*
*  Камера и настройки конвеера рендеринга
*  --------------------------------------
*  
* \note
*  Здесь и далее все создаваемые наборы рендеров добавляются в общий набор
*  объектов, а \b сцена представляет собой список идентификаторов объектов
*  в этом наборе.
*  
*  В данном примере формируется объект, состоящий из рендеров:
*  - Компонент смещения камеры таким образом, чтобы центр поля зрения оказался
*  в начале координат.
*  - Ортографической камеры.
*  - Рендера, разрешающего использовать прозрачность.
*  - Рендера настроек вывода текстуры.
*  - Рендера используемого вертексного шейдера:
*  
* \snippet .\Solution\Example\Example\Basements\Simple2DGame.cpp Create camera
*  
*  Если камера не использует буфер глубины, отрисовка объектов производится
*  в порядке вызовов их рендеров (те, что вызваны позже будут отрисованы поверх
*  тех, которые были вызваны ранее), при включенном буфере глубины видимость
*  объектов будет определяться их расположением на оси z (подробнее про
*  положение объектов см. в описании рендеринга объектов).
*  
* \note
*  При использовании буфера глубины следует учитывать, что отрисовываться
*  будут только те объекты, которые находятся вдоль оси z в диапазоне координат
*  [-1.0f...1.0f], с учетом установленного компонента масштабирования (если, 
*  например, параметр z у Data.Scale будет установлен в 0.0f, то независимо от 
*  положения на оси z все объекты будут отрисовываться в порядке вызовов их
*  рендеров).
*  
*  Рендеринг объектов
*  ------------------
*  
*  Объект, отображаемый на экране, представляет собой набор рендеров, который
*  создается на основе набора компонентов и должен включать:
*  - Вершинный шейдер.
*  - Пиксельный шейдер.
*  - Текстуру (только для текстурированных объектов).
*  - Вертексный буфер.
*  - Индексный буфер.
*  - Компоненты положения/ориентации/масштабирования (не обязательны).
*  - Present.Geometry (именно он осуществляет отрисовку объекта, поэтому
*  должен располагаться последним).
*  
*  Поскольку для различных реализаций (OpenGL или DirectX) требуются шейдеры
*  в разных форматах, для обеспечения кроссплатформенности кода необходимо 
*  предоставить шейдеры для всех поддерживаемых реализаций (например, для
*  DirectX используется компонент Data.Shader.HLSL); не подходящие для 
*  текущего графического Api будут проигнорированы при создании рендеров.
*  
*  Вертексный буфер формируется в зависимости от того, какой объект
*  (просто закрашенный цветом или текстурированный) нужно отрисовывать.
*  
*  Компоненты Data.Position/Data.Rotation/Data.Scale используются для 
*  перемещения/вращения/изменения размеров объектов без их пересоздания
*  (достаточно установить новые значения параметров при обновлении сцены), 
*  причем:
*  - Компонентов одного типа может быть несколько (что позволяет, например,
*  создавать группы объектов, которые должны быть расположены относительно
*  друг друга определенным образом, но при этом двигаться/вращаться вместе;
*  во втором случае необходимо использовать общий \b объект \b компонента,
*  использование разных объектов с одинаковым \b id нужного эффекта не даст).
*  - Важен порядок следования компонентов (поворот-перемещение даст сначала
*  поворот вокруг точки [0, 0] с нулевым радиусом, а затем уже смещение 
*  повернутого объекта, а перемещение-поворот даст сначала смещение от точки 
*  [0, 0], а затем уже поворот вокруг нее с радиусом смещения).
*  
* \todo
*  - Добавить картинку, объясняющую разницу между поворот-смещение и
*  смещение-поворот.
*
*  Поскольку одному пикселю на экране соответствует смещение на 1.0f вдоль осей
*  X и Y, существует два способа создания объектов требуемого размера:
*  - Сформировать вертексный буфер, содержащий координаты вершин в пикселях.
*  - Сформировать вертексный буфер, содержащий координаты вершин в условных
*  единицах (например, считать \b единицей ширину окна программы) и каждому
*  объекту добавить компонент Data.Scale, которому установлены параметры
*  \b x и \b y, увеличивающие координаты до нужных значений в пикселях.
*
* ### Простой объект
*  
*  Пример формирования простого залитого заданным цветом объекта; по порядку:
*  - Пиксельный шейдер для отрисовки объектов без текстуры (создан ранее,
*  поэтому используется компонент, содержащий только id).
*  - Вертексный буфер, содержащий уникальные для данного объекта данные вершин.
*  - Общий для всех объектов (создан ранее) индесный буфер.
*  - Набор компонентов локальной транформации (смещения объектов относительно
*  начала координат).
*  - Компонент масштабирования до размеров экрана (за единицу принят размер
*  центральной области игры).
*  - Компонент смещения всех объектов (тем самым устанавливается начало 
*  координат в центре экрана).
*  - Компонент отрисовки объекта.
*  
* \snippet .\Solution\Example\Example\Basements\Simple2DGame.cpp Vertex buffer
* \snippet .\Solution\Example\Example\Basements\Simple2DGame.cpp Colored object
* \snippet .\Solution\Example\Example\Basements\Simple2DGame.cpp Common object renders
*  
* \note
*  - Общий для всех объектов вертексный шейдер устанавливается вместе с камерой.
*  - Цвета разных вершин могут отличаться, что позволяет использовать 
*  градиентную заливку цветом.
*  - Текстурные координаты для такого объекта не имеют смысла и будут
*  проигнорированы.
*  
* ### Текстурированный объект
*  
*  Текстуры, которые будут использоваться, можно подгрузить заранее, чтобы
*  потом ссылаться на них по их идентификатору.
*  
* \snippet .\Solution\Example\Example\Basements\Common.cpp Load texture
*
*  Пример формирования текстурированного объекта; по порядку:
*  - Пиксельный шейдер для отрисовки объектов c текстурой (создан ранее,
*  поэтому используется компонент, содержащий только id).
*  - Текстура (создана ранее).
*  - Вертексный буфер, содержащий уникальные для данного объекта данные вершин.
*  - Общий для всех объектов (создан ранее) индесный буфер.
*  - Набор компонентов локальной транформации (смещения объектов относительно
*  начала координат).
*  - Компонент масштабирования до размеров экрана (за единицу принят размер
*  центральной области игры).
*  - Компонент отрисовки объекта.
*
* \snippet .\Solution\Example\Example\Basements\Simple2DGame.cpp Vertex buffer
* \snippet .\Solution\Example\Example\Basements\Simple2DGame.cpp Textured object
* \snippet .\Solution\Example\Example\Basements\Simple2DGame.cpp Common object renders
*  
* \note
*  - Общий для всех объектов вертексный шейдер устанавливается вместе с камерой.
*  - Можно использовать текстуру, содержащую несколько изображений для
*  разных объектов, но при этом все равно необходимо устанавливать компонент 
*  этой текстуры \b каждому объекту, т.к. Present.Geometry отключает
*  использование текстур после отрисовки объекта.
*  - Цвета вершин и текстуры смешиваются (умножаются): прозрачный тексель 
*  остается прозрачным, черный остается черным, белый заменяется вторым цветом).
*  
*  Анимация
*  --------
*  
*  Последовательная отрисовка заранее подготовленных кадров анимации
*  может быть реализована несколькими способами:
*  - Создать для каждого кадра отдельный объект и в дальнейшем отрисовывать эти
*  объекты последовательно (например, перемещая указатель на следующий объект
*  при обновлении сцены).
*  - Создать объект, на который наложена текстура, содержащая \b все кадры 
*  анимации, после чего отрисовывать этот объект, используя компонент 
*  State.Scissor для выделения одного кадра и перемещая сам объект таким
*  образом, чтобы отображалась нужная часть текстуры.
*  - Создать объект, на который наложена текстура, содержащая \b все кадры
*  анимации, после чего отрисовывать этот объект, используя шейдер,
*  который будет менять текстурные координаты таким образом, чтобы отображалась
*  нужная часть текстуры.
*/
