
/**
* \page CovelliteApiBkSurface Рендеринг во внеэкранную поверхность
*  
*  Рендеринг во внеэкранную поверхность позволяет производить отрисовку
*  в текстуру(ы) которую(ые) потом можно использовать для рендеринга другой
*  сцены. Это используется для многопроходного рендеринга и реализации
*  таких техник как отложенное освещение, тени от объектов и
*  [постобработка](https://habr.com/ru/post/453692/).
*  
*  Рендеринг во внеэкранную поверхность
*  ====================================
*  
*  Логика использования рендеринга во внеэкранную поверхность подразумевает
*  рендеринг в несколько проходов.
*  - Первый проход:
*   + Создание объекта компонента \b BkSurface и набора используемых текстур,
*     в которые и будет производится рендер.
*   + Объявление и использование структуры пиксельного шейдера для вывода
*     в несколько текстур одновременно.
*  - Последующие проходы:
*   + Создание объектов текстур, содержащих данные, полученные на первом
*     проходе.
*  
*  BkSurface
*  ---------
*  
*  Сцена определяется ее камерой, внеэкранной поверхностью, настройками
*  конвеера рендеринга и расположенными в ней объектами. Следует учитывать,
*  что рендер компонента \b Camera отключает ранее активированную внеэкранную
*  поверность (т.е. переключает вывод на экран), а компоненты \b State работают
*  с текущей поверхностью рендеринга, поэтому компонент \b BkSurface необходимо
*  ставить между компонентами камеры и настроек конвеера рендеринга.
*  
*  Компонент \b BkSurface ожидает один или несколько компонентов
*  \b Data.Texture (можно использовать от 0 до 8 текстур для цветовых
*  компонентов и одну для буфера глубины), которые он установит в качестве цели
*  рендеринга всех последующих объектов:
*  - Тип цели рендеринга (цвет или глубина) определяется по параметру
*  \b destination компонента \b Data.Texture ('depth' для буфера глубины и цвет
*  для любого другого значения).
*  - Индекс цветовой поверхности (начиная с нуля) определяется порядком передачи
*  компонентов \b Data.Texture компоненту \b BkSurface.
*  
* \note
*  - Компонент \b BkSurface создаст новые текстуры для переданных ему
*  компонентов \b Data.Texture, причем их размеры будут совпадать с размерами
*  окна программы (переданные значения параметров \b width и \b height будут
*  проигнорированы).
*  - Переданным компонентам \b Data.Texture будут установлены размеры созданных
*  текстур как значения параметров \b width и \b height.
*  - При изменении размеров окна программы текстуры будут пересозданы 
*  с новыми размерами, значения параметров \b width и \b height также будут
*  перезаписаны.
*  
*  Структура шейдера
*  -----------------
*  
*  При использовании отрисовки одновременно в несколько текстур цветовых
*  компонентов необходимо при рендеринге объектов использовать пиксельный
*  шейдер, возвращающий заполненный объект специальным образом объявленной
*  структуры.
*  
* \note
*  Макрос объвления структуры мультитаргета позволяет создавать унифицированные
*  шейдеры, которые будут одинаково компилироваться и работать для реализаций
*  DirectX и OpenGL/ES3.
*  
*  Объявление (имя структуры может быть любым, число - количество целей вывода,
*  от 1 до 8):
*  
* \code
COVELLITE_DECLARE_MULTI_TARGET_STRUCTURE(PsOutput, 3);
* \endcode
*  
*  Использование:
*  
* \code
PsOutput psExample(Pixel _Value)
{
  ...
  PsOutput Result;
  Result.Target[0] = float4(...);
  Result.Target[1] = float4(...);
  Result.Target[2] = float4(...);
  return Result;
}
* \endcode
*  
*  Использование текстур
*  ---------------------
*  
*  Для использования полученных на первом проходе текстур для рендеринга
*  на следующих проходах необходимо обычным образом создать объекты компонентов
*  \b Texture, передав им те же самые объекты компонентов \b Data.Texture,
*  что были переданы компоненту \b BkSurface на первом проходе.
*  
* \note
*  Для того, чтобы на последующих проходах использовались именно те текстуры,
*  которые заполняются при рендеринге во внеэкранную поверхность, необходимо
*  обеспечить совпадение объектов компонентов \b Data.Texture, переданных
*  компоненту \b BkSurface и компонентам текстур на других проходах. Это должны
*  быть те же самые объекты классов компонентов, совпадений идентификаторов
*  недостаточно!
*/
