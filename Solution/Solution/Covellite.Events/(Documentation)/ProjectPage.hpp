
/**
* \page CovelliteEventsBriefPage
*  Проект для кода работы с событиями фреймворка.
*/

/**
* \page CovelliteEventsPage Covellite.Events
*  
*  Список классов проекта \ref CovelliteEventsGroup
*  
*  Введение
*  --------
*  
* \copydoc CovelliteEventsBriefPage
*  
*  Подробнее
*  ---------
*  
*  Классы проекта обеспечивают унификацию сообщений и их независимость от
*  того, в какой операционной системе работает приложение.
*  
* \copydoc CovelliteUsingEventsPage
*/

/**
* \page CovelliteUsingEventsPage Использование событий фреймворка
*
* ### Создание нового типа событий
*
*  Для создания пользовательского типа событий следует создать класс типа 
*  событий (в котором определить идентификаторы событий этого типа) и объявить 
*  объект нового типа событий.
*
* \code

class UserType_t final
{
public:
  enum Id
  {
    Exception = 0,
  };
};
  
namespace { UserType_t UserType; }

* \endcode
*  
* \note
*  Разные типы событий могут иметь одинаковые идентификаторы (как имена, так
*  и значения), события с такими идентификаторами будут считаться разными 
*  событиями.
*  
* ### Создание классов, которые должен реагировать на события
*  
*  Для создания класса, способного реагировать на события фреймворка необходимо
*  унаследовать нужный класс от класса covellite::events::Events и в
*  конструкторе подписаться на требуемые события.
*  
* \code

class Window final :
  public covellite::events::Events
{
public:
  Window(void)
  {
    (*this)[UserType.Exception].Connect([](const ::std::string &)
    {
      // Сюда поместить код обработки события Exception.
    });
  }
};

* \endcode
*  
*  Для того, чтобы события, которые активируются в объекте одного класса могли
*  получать объекты других классов, необходимо все классы (кроме верхнего 
*  в иерархии) создавать с конструктором, которому передается объект класса,
*  расположенного выше в иерархии классов, с передачей этого объекта 
*  конструктору базового класса.
*  
* \code

class Window2 final :
  public covellite::events::Events
{
public:
  Window2(const Window & _Window) :
    Events(_Window)
  {
    (*this)[UserType.Exception].Connect([](const ::std::string &)
    {
      // Сюда поместить код обработки события Exception.
    });
  }
};

* \endcode
*  
* ### Активация события
*  
*  Для активации события необходимо вызвать оператор () из функции любого 
*  класса, унаследованного от класса событий. В качестве параметра (который
*  предусмотрен только один) может быть передан объект любого класса
*  (тип должен совпадать с типом, указанным у обработчика, в противном случае
*  будет сгенерировано исключение). Для вызова обработчика без параметров
*  использовать объект covellite::events::params::Empty{}.
*  
* \code

Window Window;
Window2 Window2{ Window };
  
const ::std::string Description = "Exception description".
  
// Все равно, через какой объект активировать событие...
Window[UserType.Exception](Description); // ... или
Window2[UserType.Exception](Description);
// в любом случае будут вызваны оба обработчика - и из класса Window, 
// и из класса Window2.

* \endcode
*/
